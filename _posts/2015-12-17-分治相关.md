---
layout: post
title: '分治相关'
date: 2015-12-17 11:34
comments: true
categories: 
--
讲一些分治相关的东西。。<br>

---
<br>

# cdq分治
如果修改操作是独立可叠加的。。。那么就可以应用cdq分治来干一些东西。。。。<br>
每次处理区间左半部分对区间右半部分的影响。。递归下去就可以了。。。。。<br>

---

# 二进制分组
其实窝觉得这是cdq分治一个很好的替代品<br>
<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script>
窝们可以把修改进行二进制分组...有新的东西加进来就把要修改的东西打散重来...<br>
考虑到$$\sum lowbit(i) = O(nlogn)$$<br>
所以可以通过一个log的代价实现把强制在线改成强制离线<br>

---

#整体二分
整体二分要求修改独立可叠加，答案可二分<br>
整体二分是把所有询问一起二分。然后再接着按每个询问在答案下面还是上面递归下去<br>
如果递归下去时不能把操作也递归下去那么复杂度就是错的<br>

---

#利用线段树分治
考虑到线段树的形态与cdq分治相似，那么窝们就可以用线段树来兹磁cdq分治

对于每个修改操作，对每个区间打个tag，表示这个区间需要被影响。

这样能无伤兹磁删除操作（因为删除操作使得某个修改操作对应的时间区间仍然是连续的

然而这样空间复杂度不太对。。可以使用bfs一边插一边算答案来使空间复杂度变为$$O(m)$$

通常配合虚序列（雾）与虚树一起使用

---

#虚树
直接把每个关键点和它们的lca加上去就好啦

想要找出每个点对应的虚树节点可以维护dfs序

初始化的时候按深度从小到大往里面就好啦

---

#区间赋值转化为添加和删除
建一颗位置线段树

按照时间处理每一个区间赋值

在位置线段树中找到每一个节点，边走的时候记得边pushdown，把它们都打上tag

并且把找到的节点的子树所有tag清空。即把它们的删除时间都设为现在的时间

考虑所有tag总深度进行分析可以发现构造时间复杂度不超过$$O(nlog^2n)$$,出来的操作数为$$O(mlogn)$$

有没有更好的方法呢？

考虑到每个子树的所有tag可能有些可以合并

比如窝现在在$$[1,4]$$这里新打了个tag..然后窝$$[1,2]$$,$$[2,3]$$这里都有插入$$key~2$$.那么最后转化的时候把它看成“在时间$$x$$在$$[1,3]$$插入$$key~2$$,在时间$$y$$撤销此操作”

考虑颜色块数不会超过$$2m$$,那么构造时间复杂度$$O(nlogn)$$,出来操作数为$$O(m)$$

多好，这样就能出题了
