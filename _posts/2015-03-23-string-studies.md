---
layout: post
title: '字符串学习'
date: 2015-03-23 15:06
comments: true
categories: 
---
##### 网络流切完啦~来切字符串
<!--more-->
---
# KMP
KMP是基于暴力的优化，对于每一次配对失败后，它不是直接回去，而是通过之前的计算退回到一个最优的位置，即next[i];
设fail[j]表示在第j项匹配成功，，但下一项失败j要回去到哪一项开始
即求一个k，使s[1..k]=s[j-k+1..j] 且k最大
可以依靠原有的基础上求解
if s[fail[j-1]+1]=s[j] then fail[j]:=fail[j-1]+1;
否则呢？if s[fail[fail[j-1]]+1]=s[j] then fail[j]:=fail[fail[j-1]]+1;
为什么呢？
可以看到
由fail的定义可得，s[fail[fail[j-1]]]之前的字符串和s[j]之前相同数量的字符串是一样的
那么又相等就是原来的+1了
我们注意到KMP的fail还有很多很有意思的性质
记fail[i]=j,那么s[1,i-j]=s[i-j+1,i-j+i-j],是一个循环节


---
# AC自动机
AC自动机其实是一个很暴力的东西
它只不过是一个Trie顺带维护一个Fail指针
其中Fail指针指向的是这颗Trie所有子串里面它的最长后缀
利用Fail指针，我们可以搞出很多有趣的东西
最经典的应用就是 NOI 阿狸的打字机..
还记得去年讲的时候还是云里雾里（其实是根本没听懂在说什么..
今年一看...这不是傻逼题么...

---
# 后缀数组
利用倍增来求出sa,rank数组，最后利用这两个数组来求出height数组..
...相同的题目用Suffix Tree或者Suffix Automan会更直接...

---

# 后缀自动机
这才是我要讲的重点
后缀自动机有很多很好的性质
首先，它的parent指向一定是它的后缀.
所以SAM是一个..既有后缀,又有前缀的东西.
而在构造sam的时候..之所以有时要把q拆成nq，是因为之前的q还包含其他东西，要通过拆分的形式，使得nq不会去影响q.
要求某个状态的right（即该状态总共在原串中出现过多少次），利用parent树反向递推即可
要topsort时可以使用计数排数来代替.
广义后缀自动机也是相当水..只要把last=root即可.

---

配上一些习题

【bzoj 1031】 把串延长一倍搞后缀数组即可
【bzoj 1212】 利用AC自动机求匹配位置，然后DP
【bzoj 2434】 建出AC自动机后建出fail树，对fail树求出dfs序后用树状数组维护.
【bzoj 2555】 后缀自动机.每次在后面加东西的时候顺便用LCT维护一下parent树,查询的时候在后缀自动机走一下看当前节点right.
【bzoj 2754】 AC自动机+fail树，之后搞一搞就可以了
【bzoj 2865】 后缀数组求出每个节点开始的最短无重复子串，弄两颗线段树算答案
【bzoj 3172】 模板题
【bzoj 3230】 后缀数组. 每次询问二分得出是哪个子串然后求lcp
【bzoj 3238】 建出后缀树后在后缀树上面算一算贡献
【bzoj 3926】 建出广义后缀自动机之后...就没了
【bzoj 3998】 后缀自动机.重复的算一个直接后缀自动机暴力走.重复算多个先算right再暴力走.
【spoj DISUBSTR】 可以用后缀自动机后者后缀数组..反正只要建出来之后暴力搞一搞...
【spoj LCS】 一个串建后缀自动机后另外一个串在上面跑，如果匹配不了就往parent上跑，同时记录最大答案
【spoj LCS2】 先对于一个串建后缀自动机.其余每个串都到上面跑一跑，同时记录后缀自动机上某个节点所有匹配最大值里的最小值，计算一下答案即可.
【spoj SubStrings】 建出后缀自动机后求right，对于每一个节点f[len]=max(f[len],right),最后从后向前更新答案.

---

完结撒花~
