---
layout: post
title: '字符串学习'
date: 2015-03-23 15:06
comments: true
categories: 
---
##### 网络流切完啦~来切字符串
<!--more-->
---

# KMP

<br>

KMP是基于暴力的优化，对于每一次配对失败后，它不是直接回去，而是通过之前的计算退回到一个最优的位置，即next[i];<br>
设fail[j]表示在第j项匹配成功，，但下一项失败j要回去到哪一项开始<br>
即求一个k，使s[1..k]=s[j-k+1..j] 且k最大<br>
可以依靠原有的基础上求解<br>
if s[fail[j-1]+1]=s[j] then fail[j]:=fail[j-1]+1;<br>
否则呢？if s[fail[fail[j-1]]+1]=s[j] then fail[j]:=fail[fail[j-1]]+1;<br>
为什么呢？<br>
可以看到<br>
由fail的定义可得，s[fail[fail[j-1]]]之前的字符串和s[j]之前相同数量的字符串是一样的<br>
那么又相等就是原来的+1了<br>
我们注意到KMP的fail还有很多很有意思的性质<br>
记fail[i]=j,那么s[1,i-j]=s[i-j+1,i-j+i-j],是一个循环节<br>
<br>
<br>

---

# AC自动机
AC自动机其实是一个很暴力的东西<br>
它只不过是一个Trie顺带维护一个Fail指针<br>
其中Fail指针指向的是这颗Trie所有子串里面它的最长后缀<br>
利用Fail指针，我们可以搞出很多有趣的东西<br>
最经典的应用就是 NOI 阿狸的打字机..<br>
还记得去年讲的时候还是云里雾里（其实是根本没听懂在说什么..<br>
今年一看...这不是傻逼题么...<br>
<br>

---
<br>

# 后缀数组
利用倍增来求出sa,rank数组，最后利用这两个数组来求出height数组..<br>
...相同的题目用Suffix Tree或者Suffix Automan会更直接...<br>
<br>
---

# 后缀自动机
这才是我要讲的重点<br>
后缀自动机有很多很好的性质<br>
首先，它的parent指向一定是它的后缀<br>.
所以SAM是一个..既有后缀,又有前缀的东西.<br>
而在构造sam的时候..之所以有时要把q拆成nq，是因为之前的q还包含其他东西，要通过拆分的形式，使得nq不会去影响q.<br>
要求某个状态的right（即该状态总共在原串中出现过多少次），利用parent树反向递推即可<br>
要topsort时可以使用计数排数来代替.<br>
广义后缀自动机也是相当水..只要把last=root即可.<br>
<br>
---

配上一些习题

【bzoj 1031】 把串延长一倍搞后缀数组即可<br>
【bzoj 1212】 利用AC自动机求匹配位置，然后DP<br>
【bzoj 2434】 建出AC自动机后建出fail树，对fail树求出dfs序后用树状数组维护.<br>
【bzoj 2555】 后缀自动机.每次在后面加东西的时候顺便用LCT维护一下parent树,查询的时候在后缀自动机走一下看当前节点right.<br>
【bzoj 2754】 AC自动机+fail树，之后搞一搞就可以了<br>
【bzoj 2865】 后缀数组求出每个节点开始的最短无重复子串，弄两颗线段树算答案<br>
【bzoj 3172】 模板题<br>
【bzoj 3230】 后缀数组. 每次询问二分得出是哪个子串然后求lcp<br>
【bzoj 3238】 建出后缀树后在后缀树上面算一算贡献<br>
【bzoj 3926】 建出广义后缀自动机之后...就没了<br>
【bzoj 3998】 后缀自动机.重复的算一个直接后缀自动机暴力走.重复算多个先算right再暴力走.<br>
【spoj DISUBSTR】 可以用后缀自动机后者后缀数组..反正只要建出来之后暴力搞一搞...<br>
【spoj LCS】 一个串建后缀自动机后另外一个串在上面跑，如果匹配不了就往parent上跑，同时记录最大答案<br>
【spoj LCS2】 先对于一个串建后缀自动机.其余每个串都到上面跑一跑，同时记录后缀自动机上某个节点所有匹配最大值里的最小值，计算一下答案即可.<br>
【spoj SubStrings】 建出后缀自动机后求right，对于每一个节点f[len]=max(f[len],right),最后从后向前更新答案.<br>
<br>

---

<br>
完结撒花~
