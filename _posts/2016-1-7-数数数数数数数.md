---
layout: post
title: '数数数数数数数'
date: 2016-1-7 17:17
comments: true
categories:
---
<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script>

<div align="center">$$clscls?clscls!$$</span></p></div>

---


<br>
<br>
<div align="center"><span style="font-size:80px;color:#7bbfea;"   >4</span></p></div>
<br>

<!--more-->

---

以下所写题目源代码都在窝github上能找到。

---

1.给一个无向图。求有多少个它的边子图使得这个图双联通

令$$f(S)$$为集合$$S$$的双联通子图数，$$g(S)$$为集合$$S$$的非双联通子图数。那么显然可得

$$f(S)+g(S)=conn(S)$$

$$conn(s)$$为集合$$S$$的联通子图数

对于一个非双联通子图，那么显然可以把它缩双联通分量使得它成为一颗森林。所以只要枚举编号最小点所在的双联通分量，就能计算$$g(S)$$了，即

$$g(S)=\sum_{T \subset S,a \in T}f(T)\times g(S-T)\times way(T,S-T)$$

$$way(T,S-T)$$表示把$$T$$接到$$S-T$$的方案数。这个非常容易计算。

---

2.给一个有向图，求有多少个它的边子图使得这个图强连通

对于一个非强连通子图，那么显然可以把它缩强连通分量使得它成为一个DAG.

所以一个初始的想法就是先枚举这个图的强连通分量划分。然后注意到一个DAG能通过删去出度为0的点得到一个新的DAG，所以我们猜想

令$$f(S)$$为集合$$S$$的强连通子图数，$$g(S)$$为集合$$S$$的非强连通子图数。可得

$$f(S)+g(S)=2^{edge(S)}$$

与

$$g(S)=\sum_{T \subseteq S}g(S-T)\times 2^{edge(S-T,T)}$$

然而上面的式子是错的。因为会**重复计算**。所以需要容斥

$$g(S)=\sum_{T \subseteq S}g(S-T)\times 2^{edge(S-T,T)} \times (-1)^{|T|-1}$$

然而这样复杂度太大了。我们考虑能不能把容斥一起做掉呢？

令$$g(S)$$分成若干个强连通分量的方案数,并且奇数个强连通分量对方案贡献为正，否则为负

那么容易得到

$$g(S)=f(S)-\sum_{T \subset S,a \in T}f(T)\times g(S-T)$$

这里是减去后面的那个卷积是因为多了一个强连通分量对答案的贡献就变成原来的相反数了

这样$$f(S)$$也能计算了。根据之前的推导，易得

$$f(S)=2^{edge(x)}-\sum 2^{edge(S-T,T)+edge(S-T)} \times g(T)$$

就能在$$O(3^n)$$时间复杂度内解决问题了

---

3.有一行$$n$$个黑球.每次选择一个区间把区间内球染黑.问期望多少次操作后全部球都是白色?

令$$P[i]$$表示$$i$$次后仍然没有全白的几率，那么可得

$$Ans=\sum_{i=0}^{\infty}P[i]$$

窝们考虑枚举剩下了哪些黑球。那么就要求选的区间不能包含这个黑球。

这是能直接计算的.

所以

$$p=\frac{可选区间}{全部区间}$$

而且

$$\sum_{i=0}^{\infty} p = \frac{1}{1-p}$$

然而窝们注意到这是有重叠的.比如在算五个球的期望是会顺便算六个球的.所以要容斥

然而直接枚举黑球显然是不可行的.

注意到窝们要求的只跟选择的黑球个数与可行区间数量有关

令$$f(i,j,k)$$表示有 上个黑球的位置是$$i$$,有$$j$$个可行区间,有奇数/偶数个黑球的选择总数，然后DP之后就能直接计算了

---

4.给定串$$S$$。问长度为$$m$$的与串$$S$$的LCS为$$i$$的串$$T$$有多少个？

所谓DP套DP,就是把内层DP的值当成外层DP的状态。

本题把内层DP(LCS)的值当成外层计数DP的状态。

注意到LCS做DP的时候$$0 \leq f[i][j]-f[i][j-1] \leq 1$$

所以作差之后得出它的状态.

注意到如果一个LCS $$f[i-1]$$数组和$$a[i]$$都是确定的话,那么$$f[i]$$也是确定的。所以可以借此压缩信息来DP。

令$$g[i][S]$$表示m串确定到第$$i$$个,并且此时窝与串$$T$$的LCS数组是$$S$$的串有多少个

预处理出某个状态$$S$$在串$$T$$的下一位确定为$$a[i]$$后会变成什么状态，然后直接转移就好。

复杂度$$O(2^nm)$$
